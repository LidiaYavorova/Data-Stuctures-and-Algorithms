## Увод

Множество от цели числа без повторение на елементите ще представяме чрез описания по-долу клас.

```cpp
class IntegerSet {
private:
  // Добавете подходящи член-данни

public:
  IntegerSet();
  IntegerSet(const IntegerSet&);
  IntegerSet& operator=(const IntegerSet&);
  ~IntegerSet();

public:
  // Връща броя на елементите в множеството
  size_t size() const;

  /// Проверява дали елемент се съдържа в множество
  bool countains(int) const;

  /// Проверява дали две множества се състоят от едни и същи елементи
  bool equals(const IntegerSet&) const;

  /// Проверява дали текущият обект е подмножество на друг
  bool subsetOf(const IntegerSet&) const;

  /// Връща обединението на две множества
  IntegerSet getUnion(const IntegerSet&) const;
  
  /// Връща сечението на две множества
  IntegerSet getIntersection(const IntegerSet&) const;

  /// Десериализира съдържанието на едно множество.
  /// Новата информация напълно заменя старата.
  void deserialize(std::istream&);

  /// Сериализира съдържанието на едно множество
  void serialize(std::ostream&) const;
};

inline std::istream& operator>>(std::istream& in, IntegerSet& set)
{
  set.deserialize(in);
  return in;
}

inline std::ostream& operator<<(std::ostream& out, const IntegerSet& set)
{
  set.serialize(out);
  return out;
}
```

Реализирайте всички операции на класа.

Позволено е (и желателно) да добавите допълнителни помощни функции в класа `IntegerSet`.

Вътрешно множеството трябва да се представи като двоично наредено дърво. Представянето на дървото да бъде чрез обекти от вида:

```cpp
class Node {
public:
  int value;
  Node* left;
  Node* right;
};
```

Можете да добавите допълнителни членове към класа `Node`.

Ако в някоя от операциите възникне проблем при заделяне на паметта, да се хвърля изключение от тип `std::bad_alloc`.

За всяка от операциите се уверете, че не се допуска изтичане на памет. Например, ако дървото е построено донякъде и след това се получи грешка при заделяне на памет, трябва да почистите заделените до момента ресурси.

## Сериализация/десериализация

Съдържанието на едно множество представяме чрез символен низ като последователност от числа -- най-напред число N указващо броя на елементите, следвано от точно N числа Наредени в строго нарастващ ред. Например, множеството {10, 20, 30} представяме като:

```text
3 10 20 30
```

Операциите по сериализация и десериализация трябва да извеждат/въвеждат само информацията нужна за множеството и да не добавят/извличат друга информация от съответния поток. Например:

```cpp
// съдържа представянето на две множества и две думи
std::stringstream str("3 10 20 30 hello 2 100 200 world");
IntegerSet s1, s2;
std::string w1, w2;

// Въвежда от потока две множества и две думи
str >> s1 >> w1 >> s2 >> w2;

// Извежда "This is a set: -- 3 10 20 30 --"
std::cout << "This is a set: -- " << s1 << " --";
```

При десериализацията проверявайте за коректността на входа. Ако възникне проблем, да се хвърли изключение от тип `std::runtime_error`.
